# http协议 {ignore}
> url地址全称为Uniform Resource Locator，统一资源定位符，是一个字符串，它的格式如下：
```
protocol://hostname:port/path?query#hash
```

- protocal: 使用的协议，选择不同的协议，会导致和服务器之间消息交互格式、连接方式不同，大部分都服务器支持 http 和 https 两种协议。如果选择了服务器不支持的协议，会导致访问失败。
- hostname：主机名，可以是 ip、域名
  - ip：每台计算机在网络中的唯一编号，127.0.0.1表示本机
  - 域名：网络中容易记忆的唯一单词，通过DNS服务器可以将域名解析成IP，localhost会被解析为127.0.0.1
- port：端口号，0~65535之间的数字，相当于服务器计算机上的房号，使用不同的端口号相当于敲不同房间的门。计算机上的程序可以监听一个或多个端口号，如果访问的端口号有程序被监听，则计算机会将到达的网络访问交给对应的程序来处理
  - 端口号可以不写，使用默认值
  - http协议默认值80
  - https协议默认值443
- path: 一个普通的字符串，该字符串会交给web服务器处理，主要用于定位服务
  - 如果path为```/```，则表示根路径，如```http://www.baidu.com/```的path就是```/```
- query: 一种特殊格式的字符串，该字符串会交给web服务器处理，主要用于向服务器某个服务传递一些信息
  - 格式为：```属性名=属性值&属性名=属性值```
- hash：一个普通的字符串，在浏览器的地址栏中，如果url其他位置的信息保持不变，仅变动hash，浏览器不会重新访问服务器，因此通常用于不刷新的页面内跳转

可以看出：

- hostname是用于精准定位计算机的
- port是用于精准定位服务器的
- protocal是用于告诉服务器使用哪种协议进行传输数据
- path是用于精准定位服务器上的服务的
- query是在使用服务的时候传递的额外信息，具体看服务器要求
- hash是一些额外信息，服务器要不要用具体看服务器要求

示例：分析出下面url地址的各部分内容

```
https://baike.baidu.com/item/HTML?a=1#1
```

注意：url仅支持ASCII字符，如果是包含非ASCII字符，会被现代浏览器自动进行编码

例如：

```https://www.baidu.com/s?wd=王思聪```

会被编码为

```https://www.baidu.com/s?wd=%E7%8E%8B%E6%80%9D%E8%81%AA```

> url地址不能过长，因为很多浏览器对url地址长度是有限制的，chrome对url的长度限制为8182个ASCII字符

## http协议

我们可以通过url地址访问服务器，但是，浏览器和服务器之间的数据到底是怎么交互的，数据的格式是什么，这取决于使用什么协议

最常见的协议，就是http协议
- http弊端：无法保证传输数据的秘密性，无法保证信息的完整性和准确性，因为传输的过程数据可能被篡改，替换，服务端无法判断数据是否被篡改，无法保证消息来源的可靠性，服务端无法判断数据就是来自于客户端。
http协议将和服务器的一次交互看作是两段简单的过程组成：**请求 request**和**响应 response**

- 请求：客户端通过url地址发送数据到服务器的过程
- 响应：服务器收到请求数据后回馈数据给客户端的过程

![](assets/2019-12-26-18-21-28.png)

当 请求-响应 完成后，本次交互结束，如果需要得到额外的服务，则需要重新发送新的请求

同时，http协议约定了请求的消息格式和响应的消息格式

### 请求消息格式

请求消息格式有两部分组成：**请求头 request headers** 和 **请求体 request body**

#### 请求头

请求头是一个多行文本的字符串

比如我们请求 http://www.baidu.com/s?wd=html, 得到的请求头可能如下：

```
GET /s?wd=html HTTP/1.1
Host: www.baidu.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36
...
```

可以看出，该字符串有两个部分组成

1. 请求行：请求方法 path 协议
   1. 请求方法：一个普通的字符串，会被服务器读取到。常见的请求方法：**GET**、**POST**
   2. path：即url中的 path + search + hash，服务器可能会用到path中的信息
   3. 协议：协议以及版本号，目前固定为 HTTP/1.1
2. 键值对：大量的属性名和属性值组合，可以自定义。
   1. Host：url地址中的hostname
   2. User-Agent：客户端信息描述
   3. 其他键值对

请求头描述了请求的**元数据**信息，这里的元数据信息是指与业务无关的额外信息
3. 请求头：
   1. cookie：
   2. connection: keep-alive:http1中用来表示长连接的,建立一次链接后不会断开，可以一直发送数据。
当我们在浏览器地址栏输入一个url按下回车后，浏览器会自动构建一个请求头，请求方法为GET，然后向服务器发送请求

#### 请求体

包含业务数据的字符串

理论上，请求体可以是任意格式的字符串，但习惯上，服务器普遍能识别以下格式：

- application/x-www-form-urlencoded：```属性名=属性值&属性名=属性值...```
- application/json：```{"属性名":"属性值", "属性名":"属性值"}```
- multipart/form-data：使用某个随机字符串作为属性之间的分隔符，通常用于文件上传

由于请求体格式的多样性，服务器在分析请求体时可能无法知晓具体的格式，从而不知道如何解析请求体，因此，服务器往往要求在请求头中附带一个属性```Content-Type```来描述请求体使用的格式

例如

```
Content-Type: application/x-www-form-urlencoded
Content-Type: application/json
Content-Type: multipart/form-data
```

#### GET 和 POST

虽然http协议并没有规定请求方法必须是什么，但随意的请求方法服务器可能无法识别

服务器一般都能识别GET和POST请求，并做出以下的差异化处理

1. 如果是GET请求，不读取请求体，业务数据从path的search或hash中读取
2. 如果是POST请求，读取请求体，业务数据从请求体中获取，关于请求体的格式，不同的服务器、同一个服务器的不同服务要求不同

> 在浏览器地址栏中输入url地址是不能产生POST请求的，可以使用表单提交产生POST请求

由于服务器对GET和POST处理的差异，造成了GET和POST请求的差异：

1. GET请求一般没有请求体，POST请求有
2. GET请求的业务数据放在地址中，安全性较差（误分享、被偷窥）
3. GET请求传递的业务数据量是有限的，POST是无限的（除非服务器限制）
4. GET请求利于分享页面结果，POST不行
5. 在浏览器中刷新或回退页面时，会按照该页面之前的请求方式重新发送请求，如果是GET请求，浏览器会重新发送GET请求；如果是POST请求，浏览器会重新构建之前的消息体数据，通常会弹出提示

### 响应消息格式

和请求类似，响应消息也分为**响应头**(response headers)和响应体(response body)

#### 响应头

比如我们请求 http://www.baidu.com/s?wd=html, 得到的响应头可能如下：

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=utf-8
Server: BWS/1.1
...
```

可以看出，该字符串有两个部分组成

1. 响应行：协议 状态码 状态文本
   1. 协议：协议以及版本号，目前固定为 HTTP/1.1
   2. 状态码和状态文本：一个数字和数字对应的单词，来描述服务器的响应状态，浏览器会根据该状态码做不同的处理。
      1. 200 OK：一切正常。你好，```我好，大家好。```
      2. 301 Moved Permanently：资源已被永久重定向。```你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了```
      3. 302 Found：资源已被临时重定向。```你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了```
      4. 304 Not Modified：文档内容未被修改。```你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事```
      5. 400 Bad Request：语义有误，当前请求无法被服务器理解。```你给我发的是个啥啊，我听都听不懂```
      6. 403 Forbidden：服务器拒绝执行。```你的请求我已收到，但是我就是不给你东西```
      7. 404 Not Found：资源不存在。```你的请求我收到了，但我没有你要的东西```
      8. 500 Internal Server Error：服务器内部错误。```你的请求我已收到，但这道题我不会，解不出来，先睡了```
      9. 通常认为，0~399之间的状态码都是正常的，其他是不正常的
2. 键值对：大量的属性名和属性值组合，可以在服务器响应的时候自定义。
   1. Content-Type：响应体中的数据格式，常见格式如下
      1. text/plain: 普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上
      2. text/html：html文档，浏览器通常会将响应体作为页面进行渲染
      3. text/javascript：js代码，浏览器通常会使用JS执行引擎将它解析执行
      4. text/css：css代码，浏览器会将它视为样式
      5. image/jpeg：浏览器会将它视为jpg图片
      6. attachment：附件，浏览器看到这个类型，通常会触发下载功能
      7. 其他MIME类型
   2. Server：web服务器类型

#### 响应体

响应消息的正文

## 在浏览器地址栏中输入一个页面地址，按下回车键后发生了什么？

1. 浏览器将url地址补充完整：没有书写协议，添加上协议
2. 浏览器对url地址进行url编码：如果url地址中出现非ASCII字符，则浏览器会对其进行编码
3. 浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器的响应，此时浏览器标签页往往会出现一个等待的图标
4. 服务器接收到请求，将一个HTML页面代码组装到消息体中，响应给浏览器
5. 浏览器拿到服务器的响应后，丢弃掉当前页面，开始渲染消息体的html代码。浏览器之所以直到这是一个html代码，是因为服务器的响应头指定了消息类型为text/html
6. 浏览器在渲染页面的过程中，发现有其他的嵌入资源，如CSS、JS、图片等
7. 浏览器使用不阻塞渲染的方式，重新向服务器发送对该资源的请求，拿到响应结果后根据Content-Type做相应处理
8. 当所有的资源都已下载并处理后，浏览器触发window.onload事件

## ajax

不仅仅是浏览器可以发出请求并获得响应，任何具有网络通信能力的程序均可以这样做。

过去，在浏览器中，只有浏览器本身有发送请求的能力，直到ajax的出现。

ajax是一种技术，让JS语言在浏览器环境中获得了新的API，通过该API，JS代码拥有了和服务器通信的能力

传统的ajax代码如下

```js
var xhr = new XMLHttpRequest(); //创建发送请求的对象
xhr.onreadystatechange = function(){ //当请求状态发生改变时运行的函数
    // xhr.readyState： 一个数字，用于判断请求到了哪个阶段
    // 0: 刚刚创建好了请求对象，但还未配置请求（未调用open方法）
    // 1: open方法已被调用
    // 2: send方法已被调用
    // 3: 正在接收服务器的响应消息体
    // 4: 服务器响应的所有内容均已接收完毕
        
    // xhr.responseText： 获取服务器响应的消息体文本

    // xhr.getResponseHeader("Content-Type") 获取响应头Content-Type
}
xhr.setRequestHeader("Content-Type", "application/json"); //设置请求头
xhr.open("请求方法", "url地址"); //配置请求
xhr.send("请求体内容"); //构建请求体，发送到服务器
```

> 使用ajax访问：http://yuanjin.tech:5100/api/local

### 三次握手
- 三次握手主要是为了确认两台主机都具备收和发的能力
 1. 第一次：请求建立连接 建立连接用SYN=1表示，序列号用seq=n表示，n为一个数 249，**第一次握手让让主机B知道了主机A可以发送消息**
 2. 第二次：同意建立连接SYN=1，二是确认收到了刚才的信息ack seq+1，三是发送自己的序列号seq = x；**第二次握手让主机A知道了主机B可以接收到消息，和发送消息**
 3. 第三次：一是表示开始发送SYN=0，二是成功收到了B的消息 ack=刚才的seq+1，三是发送自己的序列号seq=最开始的序列号+1 **第三次握手让B知道了A可以接收到消息**

### 四次挥手
- 有AB主机传输数据，
   1. 当主机A向主机B发送数据时，数据传输完了，但是并不可以断开连接，因为B不知道A数据传输完了，所以A告诉B传输完了。**第一次挥手A告诉B数据发完了**
   2. B还没有接收完数据，虽然A把数据传完了，所以只能先回复A，知道A，知道你发完了 **第二次挥手：B知道A发完了**
   3. B知道A发完了数据，但是A不知道B是否接收完了，**第二次挥手B告诉A数据接收完了**
   4. 这是A知道B，接收完数据了，就可以放心的断开连接了，**第四次挥手：A知道B接收完了**

   为什么不是三次挥手
   因为虽然当A告诉b发完了的时候，b还有可能没接收完消息，只能先回复一部分，告诉A知道A已经发完了，当消息全部接收完毕的时候，才会告诉A已经收完了。

   ### https
- ssl层传输
> 六个阶段
   1. 客户端申请建立https通信
   2. 服务端响应并向客户端传递证书
   3. 客户端验证证书，获取公钥，加密后传递给服务端
   4. 服务端接收消息，用私钥解密，告诉客户算ssl层建立完成，https建立完成
   5. 共享密钥交换完成，https建立完成后，客户端和服务器端利于共享密钥加密通信
   6. 客户端断开连接
- 对称加密，使用同一个共有秘钥进行加密，泄露风险较高。
- 非对称加密，使用公有密钥加密，服务器端用低腰进行解密。

## http发展史
- http0.9，
   1. 服务器端只能响应html格式的字符串，只有get请求
   2. http1.0, 不仅可以传输文字，还可以传输图像，视频，二进制的文件，除了get请求 还有post head命令（请求不会返回响应体，仅仅时http响应头信息，用于判断某个信息是否存在）
   3. 缺点：tcp连接一次只能发送一次请求，发送数据完毕，连接就关闭，三次握手耗费时间
- http1.1 
   1. 支持了长连接：connection：keep-alive：一个tcp可以传输多个请求
   2. 增加了缓存处理，用 expires强缓存，if-Modified-since(协商缓存)标识
   3. 增加了错误的通知管理： 新增了24个错误状态响应码，409 请求资源与当前状态冲突，410 服务器资源被永久删除
   4. 缺点：
     1. 虽然tcp连接可以发送多个请求，但是所有的数据通信都是依次进行的，如果前面的传输较慢，那么后面的就会一直等待，造成对头堵塞，
     2. 传输数据都是明文，服务器和客户端无法验证对方身份，也就无法保证数据的安全性。
     3. header头过大，传输成本高，在移动端耗费流量。
     4. keep-alive 传输图片的时候可能浪费性能，可能文件传输后，保持一段不必要的连接时间
- SPDY协议
   1. 主要解决http1.1传输效率不高的问题，这个协议在谷歌浏览器证明可行以后，就被单做http2.0的基础综合了https和http协议
   2. 降低延迟：多路复用，采用stream共享一个tcp连接，解决了对头堵塞。减低延迟的同时提高了宽带的利用率。
   3. 请求优先级，允许给每一个request设置优先级，这样重要的请求可能会被优先传输。
   4. 压缩header头。
   5. 基于https协议传输，安全了
- http2.0
   1. SPDY的升级版，支持了http传输，SYDP必须使用https
   2. 多路复用
   3. 请求优先级
   4. header合并压缩
   5. 服务器端预先推送
## JSONP原理
   1. 判断当前源是否跨域，如果同源正常发送，
   2. 不同源 生成一个script标签
   3. 再生成一个随机的callback名字，还得创建一个名字为这个的方法(因为必须是一个可以执行的js代码)。后端会返回一个cakkback()执行，里暖白的
   4. 将callback作为参数拼接在后方。
   5. 设置script标签的src，设置为要请求的接口。为啥是src
   以上是前端部分
   5. 后端接收到数据后，将返回的数据callback的值和括号包裹起来、例如callback=asd123，后端拼接asd123({a:1,b:2,c:3});
   6. 内容返回。
   7. js代码执行名字为asd123的函数
```js
  var MyJSONP = {
     ajax: function(options) {
        var 
     }
  }

```
## 安全
### CSRF 特点和原理
>                                                      